(* Program Structure *)
(* Comments: // for line comments, /* */ for block comments *)
program = { declaration } ;

declaration = type_decl
            | function_decl ;

(* Type Declarations *)
type_decl = "type" identifier [ type_params ] "=" type_expr ;

type_params = "<" identifier { "," identifier } ">" ;

type_expr = class_expr
          | enum_expr
          | type ;

class_expr = "class" "{" { field_decl | constructor_decl | function_decl } "}" ;

field_decl = ( "var" | "let" ) identifier field_type_or_init ";" ;

field_type_or_init = ":" type [ "=" expression ]
                   | "=" expression ;

constructor_decl = "constructor" identifier [ type_params ] "(" [ parameter_list ] ")" block ;

method_decl = "fun" identifier [ type_params ] "(" [ parameter_list ] ")" ":" type block ;

enum_expr = "enum" "{" enum_variant { "," enum_variant } [ "," ] "}" ;

enum_variant = identifier [ "(" type { "," type } ")" ] ;

(* Function Declaration *)
function_decl = "fun" identifier [ type_params ] "(" [ parameter_list ] ")" ":" type block ;

parameter_list = parameter { "," parameter } ;

parameter = ( "var" | "let" ) identifier ":" type ;

(* Statements *)
statement = var_decl
          | assignment
          | if_stmt
          | while_stmt
          | return_stmt
          | throw_stmt
          | try_stmt
          | block
          | expr_stmt ;

var_decl = ( "var" | "let" ) identifier [ ":" type ] "=" expression ";" ;

assignment = lvalue "=" expression ";" ;

lvalue = identifier
       | call "." identifier
       | call "[" expression "]" ;

if_stmt = "if" expression block { "elif" expression block } [ "else" block ] ;

while_stmt = "while" expression block ;

return_stmt = "return" [ expression ] ";" ;

throw_stmt = "throw" expression ";" ;

try_stmt = "try" block ( catch_clauses [ finally_clause ] | finally_clause ) ;

catch_clauses = catch_clause { catch_clause } ;

catch_clause = "catch" "(" ( "var" | "let" ) identifier ":" type ")" block ;

finally_clause = "finally" block ;

block = "{" { statement } "}" ;

expr_stmt = expression ";" ;

(* Expressions *)
expression = lambda_expr
           | logical_or ;

lambda_expr = "fun" "(" [ parameter_list ] ")" ( "=>" expression | ":" type block ) ;

logical_or = logical_and { "||" logical_and } ;

logical_and = equality { "&&" equality } ;

equality = comparison { ( "==" | "!=" ) comparison } ;

comparison = additive { ( "<" | "<=" | ">" | ">=" ) additive } ;

additive = multiplicative { ( "+" | "-" ) multiplicative } ;

multiplicative = unary { ( "*" | "/" | "%" ) unary } ;

unary = ( "!" | "-" ) unary
      | call ;

call = primary { "(" [ argument_list ] ")" | "." identifier | "[" expression "]" } ;

argument_list = expression { "," expression } ;

primary = literal
        | identifier
        | "(" expression ")"
        | constructor
        | array_literal
        | match_expr ;

constructor = identifier "{" [ field_init { "," field_init } ] "}" ;

field_init = identifier ":" expression ;

array_literal = "[" [ expression { "," expression } [ "," ] ] "]" ;

match_expr = "match" expression "{" match_arm { "," match_arm } [ "," ] "}" ;

match_arm = pattern "=>" expression ;

(* Patterns *)
pattern = enum_pattern
        | literal
        | identifier
        | "_" ;

enum_pattern = identifier "(" [ pattern { "," pattern } ] ")" ;

(* Types *)
type = function_type
     | identifier [ type_args ] { "." identifier [ type_args ] } ;

function_type = "(" [ type { "," type } ] ")" ":" type ;

type_args = "<" type { "," type } ">" ;

(* Literals *)
literal = integer_lit
        | float_lit
        | string_lit
        | boolean_lit ;

integer_lit = digit { digit } ;

float_lit = digit { digit } "." digit { digit } ;

string_lit = '"' { character } '"' ;

boolean_lit = "true" | "false" ;

(* Lexical Elements *)
identifier = letter { letter | digit | "_" } ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
       | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
       | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
       | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
       | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

character = (* any character except '"' and newline *) ;